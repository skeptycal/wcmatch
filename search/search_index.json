{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wildcard Match \ue157 Overview \ue157 Wildcard Match provides an enhanced fnmatch and glob library. In some ways it is similar to Python's builtin fnmatch and glob as it provides functions to match, filter, and glob the file system. But it adds a number of features found in Bash's globbing such as backslash escaping, brace expansion, extended glob pattern groups, etc. It also adds a path centric matcher called globmatch which functions like fnmatch , but for paths. Paths that would normally be returned when providing glob a pattern should also be properly match in globmatch . Provides features comparable to Python's builtin in fnamtch and glob . Adds support for ** in glob. Adds support for escaping characters with \\ . Add support for POSIX style character classes inside sequences: [[:alnum:]] , etc. The C locale is used for byte strings and Unicode properties for Unicode strings. Adds support for brace expansion: a{b,{c,d}} \u2192 ab ac ad . Adds support for extended match patterns: @(...) , +(...) , *(...) , ?(...) , and !(...) . Adds ability to match path names via the path centric globmatch . Provides an alternative file crawler called wcmatch . And more\u2026 Installation \ue157 Installation is easy with pip: pip install wcmatch Libraries \ue157 fnmatch : A file name matching library. glob : A file system searching and file path matching library. wcmatch : An alternative file search library built on fnmatch and globmatch .","title":"Wildcard Match"},{"location":"#wildcard-match","text":"","title":"Wildcard Match"},{"location":"#overview","text":"Wildcard Match provides an enhanced fnmatch and glob library. In some ways it is similar to Python's builtin fnmatch and glob as it provides functions to match, filter, and glob the file system. But it adds a number of features found in Bash's globbing such as backslash escaping, brace expansion, extended glob pattern groups, etc. It also adds a path centric matcher called globmatch which functions like fnmatch , but for paths. Paths that would normally be returned when providing glob a pattern should also be properly match in globmatch . Provides features comparable to Python's builtin in fnamtch and glob . Adds support for ** in glob. Adds support for escaping characters with \\ . Add support for POSIX style character classes inside sequences: [[:alnum:]] , etc. The C locale is used for byte strings and Unicode properties for Unicode strings. Adds support for brace expansion: a{b,{c,d}} \u2192 ab ac ad . Adds support for extended match patterns: @(...) , +(...) , *(...) , ?(...) , and !(...) . Adds ability to match path names via the path centric globmatch . Provides an alternative file crawler called wcmatch . And more\u2026","title":"Overview"},{"location":"#installation","text":"Installation is easy with pip: pip install wcmatch","title":"Installation"},{"location":"#libraries","text":"fnmatch : A file name matching library. glob : A file system searching and file path matching library. wcmatch : An alternative file search library built on fnmatch and globmatch .","title":"Libraries"},{"location":"changelog/","text":"Changelog \ue157 2.0.3 \ue157 FIX : In glob , properly handle files in the current working directory when give a literal pattern that matches it. 2.0.2 \ue157 FIX : wcmatch override events ( on_error and on_skip ) should verify the return is not None and not not falsy . 2.0.1 \ue157 FIX : Can't install due to requirements being assigned to setup opposed to install. 2.0.0 \ue157 Breaking Changes Version 2.0.0 introduces breaking changes in regards to flags. This is meant to bring about consistency amongst the provided libraries. Flag names have been changed in some cases, and logic has been inverted in some cases. NEW : Glob's NOBRACE , NOGLOBSTAR , and NOEXTGLOB flags are now BRACE , GLOBSTAR , and EXTGLOB and now enable the features instead of disabling the features. This logic matches the provided fnmatch and wcmatch . NEW : Glob's DOTGLOB and EXTGLOB also have the respective aliases DOTMATCH and EXTMATCH to provide consistent flags across provided libraries, but the GLOB variants that match Bash's feature names can still be used. NEW : fnmatch 's PERIOD flag has been replaced with DOTMATCH with inverted logic from what was originally provided. NEW : Documentation exposes the shorthand form of flags: FORCECASE \u2192 F , etc. FIX : Wcmatch always documented that it had the flag named EXTMATCH , but internally it was actually EXTGLOB , this was a bug though. EXTMATCH is now the documented and the actual flag to use. 1.0.2 \ue157 FIX : Officially support Python 3.7. 1.0.1 \ue157 FIX : Ensure that all patterns in glob that have a directory preceding ** but also end with ** returns the preceding directory. FIX : Fix byte conversion in path normalization. FIX : Ensure POSIX character classes, when at the start of a sequence, properly have hyphens escaped following it. [[:ascii:]-z] should convert to [\\x00-\\x7f\\\\-b] not [\\x00-\\x7f-b] . FIX : Fix an issue where we would fail because we couldn't covert raw characters even though raw character parsing was disabled. FIX : Better default for file patterns. Before if no pattern was provided for files, '*' was assumed, now it is '' , and if '' is used, all files will be matched. This works better for when full path is enabled as you get the same file matching logic. 1.0.0 \ue157 Initial release","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#203","text":"FIX : In glob , properly handle files in the current working directory when give a literal pattern that matches it.","title":"2.0.3"},{"location":"changelog/#202","text":"FIX : wcmatch override events ( on_error and on_skip ) should verify the return is not None and not not falsy .","title":"2.0.2"},{"location":"changelog/#201","text":"FIX : Can't install due to requirements being assigned to setup opposed to install.","title":"2.0.1"},{"location":"changelog/#200","text":"Breaking Changes Version 2.0.0 introduces breaking changes in regards to flags. This is meant to bring about consistency amongst the provided libraries. Flag names have been changed in some cases, and logic has been inverted in some cases. NEW : Glob's NOBRACE , NOGLOBSTAR , and NOEXTGLOB flags are now BRACE , GLOBSTAR , and EXTGLOB and now enable the features instead of disabling the features. This logic matches the provided fnmatch and wcmatch . NEW : Glob's DOTGLOB and EXTGLOB also have the respective aliases DOTMATCH and EXTMATCH to provide consistent flags across provided libraries, but the GLOB variants that match Bash's feature names can still be used. NEW : fnmatch 's PERIOD flag has been replaced with DOTMATCH with inverted logic from what was originally provided. NEW : Documentation exposes the shorthand form of flags: FORCECASE \u2192 F , etc. FIX : Wcmatch always documented that it had the flag named EXTMATCH , but internally it was actually EXTGLOB , this was a bug though. EXTMATCH is now the documented and the actual flag to use.","title":"2.0.0"},{"location":"changelog/#102","text":"FIX : Officially support Python 3.7.","title":"1.0.2"},{"location":"changelog/#101","text":"FIX : Ensure that all patterns in glob that have a directory preceding ** but also end with ** returns the preceding directory. FIX : Fix byte conversion in path normalization. FIX : Ensure POSIX character classes, when at the start of a sequence, properly have hyphens escaped following it. [[:ascii:]-z] should convert to [\\x00-\\x7f\\\\-b] not [\\x00-\\x7f-b] . FIX : Fix an issue where we would fail because we couldn't covert raw characters even though raw character parsing was disabled. FIX : Better default for file patterns. Before if no pattern was provided for files, '*' was assumed, now it is '' , and if '' is used, all files will be matched. This works better for when full path is enabled as you get the same file matching logic.","title":"1.0.1"},{"location":"changelog/#100","text":"Initial release","title":"1.0.0"},{"location":"fnmatch/","text":"wcmatch.fnmatch \ue157 from wcmatch import fnmatch Syntax \ue157 The fnmatch library is similar to the builtin fnmatch , but with some enhancements and some differences. It is mainly used for matching file names with glob patterns. For path names, Wildcard Match's globmatch is a more appropriate choice. Not all of the features listed below are enabled by default. See flags for more information. Tip When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything. ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. [[:alnum:]] POSIX style character classes inside sequences. The C locale is used for byte strings and Unicode properties for Unicode strings. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character, it will be treated as a normal character. ! Inverse pattern (with configuration, can use - instead of ! ). ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . {} Bash style brace expansions. This is applied to patterns before anything else. Slashes are generally treated as normal characters, but on windows they will be normalized: / will become \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, it will be handled. This applies to matching patterns and the file names the patterns are applied to. If case sensitivity is applied on a Windows system, slashes will not be normalized and pattern and file names will be treated as a Linux/Unix path. By default, . is not matched by * , ? , [] , and extended patterns such as *(...) . See the DOTMATCH flag to match . at the start of a filename without a literal . . POSIX Character Classes \ue157 A number of POSIX style character classes are available in the form [:posix:] . They must be used inside sequences: [[:posix:]] . For byte strings, the C locale is used, and the values will for each character class are found in the table below under ASCII . When used in a Unicode string, Unicode properties will be used. [:posix:] \\p{posix} ASCII Unicode alnum Alnum [a-zA-Z0-9] [\\p{L&}\\p{Nd}] alpha Alpha [a-zA-Z] [\\p{L&}] ascii ASCII [\\x00-\\x7F] [\\x00-\\x7F] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] [\\p{Cc}] digit Digit [0-9] [\\p{Nd}] graph Graph [\\x21-\\x7E] [^\\p{Z}\\p{C}] lower Lower [a-z] [\\p{Ll}] print Print [\\x20-\\x7E] [\\P{C}] punct Punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] [\\p{P}\\p{S}] space Space [ \\t\\r\\n\\v\\f] [\\p{Z}\\t\\r\\n\\v\\f] upper Upper [A-Z] [\\p{Lu}] xdigit XDigit [A-Fa-f0-9] [A-Fa-f0-9] API \ue157 fnmatch.fnmatch \ue157 def fnmatch ( filename , patterns , * , flags = 0 ) fnmatch takes a file name, a pattern (or list of patterns), and flags. It will return a boolean indicating whether the file name was matched by the pattern(s). >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , r '@(*.txt|*.py)' , flags = fnmatch . EXTMATCH ) True When applying multiple patterns, a file matches if it matches any of the patterns: >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , [ r '*.txt' , r '*.py' ], flags = fnmatch . EXTMATCH ) True Inverse patterns are allowed as well. >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , r '!*.py' , flags = fnmatch . NEGATE ) False >>> fnmatch . fnmatch ( 'test.txt' , r '!*.py' , flags = fnmatch . NEGATE ) True When inverse patterns are used in conjunction with other patterns, a file will be considered matched if one of the positive patterns match and none of the inverse patterns match. If only inverse patterns are applied, the file must not match any of the patterns. >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , [ r '*.txt' , r '!avoid.txt' ], flags = fnmatch . NEGATE ) True >>> fnmatch . fnmatch ( 'avoid.txt' , [ r '*.txt' , r '!avoid.txt' ], flags = fnmatch . NEGATE ) False fnmatch.filter \ue157 def filter ( filenames , patterns , * , flags = 0 ): filter takes a list of file names, a pattern (or list of patterns), and flags. It returns a list of all files that matched the pattern(s). The same logic used for fnmatch is used for filter , albeit more efficient for processing multiple files. >>> from wcmatch import fnmatch >>> fnmatch . filter ([ 'a.txt' , 'b.txt' , 'c.py' ], r '*.txt' ) ['a.txt', 'b.txt'] fnmatch.fnsplit \ue157 def fnsplit ( pattern , * , flags = 0 ): fnsplit is used to take a string of multiple patterns that are divided by | and split them into separate patterns. This is provided to help with some interfaces they might need a way to define multiple patterns in one input. It takes into account things like sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can escape the dividers if needed ( \\| ). >>> from wcmatch import fnmatch >>> fnmatch . fnsplit ( r '*.txt|*(some|file).py' , flags = fnmatch . EXTMATCH ) ('*.txt', '*(some|file).py') fnmatch.translate \ue157 def translate ( patterns , * , flags = 0 ): translate takes a file pattern (or list of patterns) and returns two lists: one for positive patterns and one for inverse patterns. The lists contain the regular expressions used for matching the given patterns. >>> from wcmatch import translate >>> fnmatch . translate ( r '*.{a,{b,c}}' , flags = fnmatch . BRACE ) (['^(?s:(?=.).*?\\\\.a)$', '^(?s:(?=.).*?\\\\.b)$', '^(?s:(?=.).*?\\\\.c)$'], []) >>> fnmatch . translate ( r '!*.{a,{b,c}}' , flags = fnmatch . BRACE | fnmatch . NEGATE ) ([], ['^(?!(?s:(?=.).*?\\\\.a)).*?$', '^(?!(?s:(?=.).*?\\\\.b)).*?$', '^(?!(?s:(?=.).*?\\\\.c)).*?$']) Flags \ue157 fnmatch.FORCECASE, fnmatch.F \ue157 FORCECASE forces case sensitivity. On Windows, this will force paths to be treated like Linux/Unix paths, and slashes will not be normalized. FORCECASE has higher priority than IGNORECASE . fnmatch.IGNORECASE, fnmatch.I \ue157 IGNORECASE forces case insensitivity. FORCECASE has higher priority than IGNORECASE . fnmatch.RAWCHARS, fnmatch.R \ue157 RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' . fnmatch.NEGATE, fnmatch.N \ue157 NEGATE causes patterns that start with ! to be treated as inverse matches. A pattern of !*.py would match any file but Python files. If used with EXTMATCH , patterns like !(inverse|pattern) will be mistakenly parsed as an inverse pattern instead of an inverse extmatch group. See MINUSNEGATE for an alternative syntax that plays nice with EXTMATCH . fnmatch.MINUSNEGATE, fnmatch.M \ue157 When MINUSNEGATE is used with NEGATE , negate patterns are recognized by a pattern starting with - instead of ! . This plays nice with the EXTMATCH option. fnmatch.DOTMATCH, fnmatch.D \ue157 By default, glob and related functions will not match file or directory names that start with dot . unless matched with a literal dot. DOTMATCH allows the meta characters (such as * ) to match dots like any other character. Dots will not be matched in [] , * , ? , or extended patterns like +(...) . fnmatch.EXTMATCH, fnmatch.E \ue157 EXTMATCH enables extended pattern matching. This includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information. fnmatch.BRACE, fnmatch.B \ue157 BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns.","title":"Fnmatch"},{"location":"fnmatch/#wcmatchfnmatch","text":"from wcmatch import fnmatch","title":"wcmatch.fnmatch"},{"location":"fnmatch/#syntax","text":"The fnmatch library is similar to the builtin fnmatch , but with some enhancements and some differences. It is mainly used for matching file names with glob patterns. For path names, Wildcard Match's globmatch is a more appropriate choice. Not all of the features listed below are enabled by default. See flags for more information. Tip When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything. ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. [[:alnum:]] POSIX style character classes inside sequences. The C locale is used for byte strings and Unicode properties for Unicode strings. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character, it will be treated as a normal character. ! Inverse pattern (with configuration, can use - instead of ! ). ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . {} Bash style brace expansions. This is applied to patterns before anything else. Slashes are generally treated as normal characters, but on windows they will be normalized: / will become \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, it will be handled. This applies to matching patterns and the file names the patterns are applied to. If case sensitivity is applied on a Windows system, slashes will not be normalized and pattern and file names will be treated as a Linux/Unix path. By default, . is not matched by * , ? , [] , and extended patterns such as *(...) . See the DOTMATCH flag to match . at the start of a filename without a literal . .","title":"Syntax"},{"location":"fnmatch/#posix-character-classes","text":"A number of POSIX style character classes are available in the form [:posix:] . They must be used inside sequences: [[:posix:]] . For byte strings, the C locale is used, and the values will for each character class are found in the table below under ASCII . When used in a Unicode string, Unicode properties will be used. [:posix:] \\p{posix} ASCII Unicode alnum Alnum [a-zA-Z0-9] [\\p{L&}\\p{Nd}] alpha Alpha [a-zA-Z] [\\p{L&}] ascii ASCII [\\x00-\\x7F] [\\x00-\\x7F] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] [\\p{Cc}] digit Digit [0-9] [\\p{Nd}] graph Graph [\\x21-\\x7E] [^\\p{Z}\\p{C}] lower Lower [a-z] [\\p{Ll}] print Print [\\x20-\\x7E] [\\P{C}] punct Punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] [\\p{P}\\p{S}] space Space [ \\t\\r\\n\\v\\f] [\\p{Z}\\t\\r\\n\\v\\f] upper Upper [A-Z] [\\p{Lu}] xdigit XDigit [A-Fa-f0-9] [A-Fa-f0-9]","title":"POSIX Character Classes"},{"location":"fnmatch/#api","text":"","title":"API"},{"location":"fnmatch/#fnmatchfnmatch","text":"def fnmatch ( filename , patterns , * , flags = 0 ) fnmatch takes a file name, a pattern (or list of patterns), and flags. It will return a boolean indicating whether the file name was matched by the pattern(s). >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , r '@(*.txt|*.py)' , flags = fnmatch . EXTMATCH ) True When applying multiple patterns, a file matches if it matches any of the patterns: >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , [ r '*.txt' , r '*.py' ], flags = fnmatch . EXTMATCH ) True Inverse patterns are allowed as well. >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.py' , r '!*.py' , flags = fnmatch . NEGATE ) False >>> fnmatch . fnmatch ( 'test.txt' , r '!*.py' , flags = fnmatch . NEGATE ) True When inverse patterns are used in conjunction with other patterns, a file will be considered matched if one of the positive patterns match and none of the inverse patterns match. If only inverse patterns are applied, the file must not match any of the patterns. >>> from wcmatch import fnmatch >>> fnmatch . fnmatch ( 'test.txt' , [ r '*.txt' , r '!avoid.txt' ], flags = fnmatch . NEGATE ) True >>> fnmatch . fnmatch ( 'avoid.txt' , [ r '*.txt' , r '!avoid.txt' ], flags = fnmatch . NEGATE ) False","title":"fnmatch.fnmatch"},{"location":"fnmatch/#fnmatchfilter","text":"def filter ( filenames , patterns , * , flags = 0 ): filter takes a list of file names, a pattern (or list of patterns), and flags. It returns a list of all files that matched the pattern(s). The same logic used for fnmatch is used for filter , albeit more efficient for processing multiple files. >>> from wcmatch import fnmatch >>> fnmatch . filter ([ 'a.txt' , 'b.txt' , 'c.py' ], r '*.txt' ) ['a.txt', 'b.txt']","title":"fnmatch.filter"},{"location":"fnmatch/#fnmatchfnsplit","text":"def fnsplit ( pattern , * , flags = 0 ): fnsplit is used to take a string of multiple patterns that are divided by | and split them into separate patterns. This is provided to help with some interfaces they might need a way to define multiple patterns in one input. It takes into account things like sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can escape the dividers if needed ( \\| ). >>> from wcmatch import fnmatch >>> fnmatch . fnsplit ( r '*.txt|*(some|file).py' , flags = fnmatch . EXTMATCH ) ('*.txt', '*(some|file).py')","title":"fnmatch.fnsplit"},{"location":"fnmatch/#fnmatchtranslate","text":"def translate ( patterns , * , flags = 0 ): translate takes a file pattern (or list of patterns) and returns two lists: one for positive patterns and one for inverse patterns. The lists contain the regular expressions used for matching the given patterns. >>> from wcmatch import translate >>> fnmatch . translate ( r '*.{a,{b,c}}' , flags = fnmatch . BRACE ) (['^(?s:(?=.).*?\\\\.a)$', '^(?s:(?=.).*?\\\\.b)$', '^(?s:(?=.).*?\\\\.c)$'], []) >>> fnmatch . translate ( r '!*.{a,{b,c}}' , flags = fnmatch . BRACE | fnmatch . NEGATE ) ([], ['^(?!(?s:(?=.).*?\\\\.a)).*?$', '^(?!(?s:(?=.).*?\\\\.b)).*?$', '^(?!(?s:(?=.).*?\\\\.c)).*?$'])","title":"fnmatch.translate"},{"location":"fnmatch/#flags","text":"","title":"Flags"},{"location":"fnmatch/#fnmatchforcecase","text":"FORCECASE forces case sensitivity. On Windows, this will force paths to be treated like Linux/Unix paths, and slashes will not be normalized. FORCECASE has higher priority than IGNORECASE .","title":"fnmatch.FORCECASE, fnmatch.F"},{"location":"fnmatch/#fnmatchignorecase","text":"IGNORECASE forces case insensitivity. FORCECASE has higher priority than IGNORECASE .","title":"fnmatch.IGNORECASE, fnmatch.I"},{"location":"fnmatch/#fnmatchrawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' .","title":"fnmatch.RAWCHARS, fnmatch.R"},{"location":"fnmatch/#fnmatchnegate","text":"NEGATE causes patterns that start with ! to be treated as inverse matches. A pattern of !*.py would match any file but Python files. If used with EXTMATCH , patterns like !(inverse|pattern) will be mistakenly parsed as an inverse pattern instead of an inverse extmatch group. See MINUSNEGATE for an alternative syntax that plays nice with EXTMATCH .","title":"fnmatch.NEGATE, fnmatch.N"},{"location":"fnmatch/#fnmatchminusnegate","text":"When MINUSNEGATE is used with NEGATE , negate patterns are recognized by a pattern starting with - instead of ! . This plays nice with the EXTMATCH option.","title":"fnmatch.MINUSNEGATE, fnmatch.M"},{"location":"fnmatch/#fnmatchdotmatch","text":"By default, glob and related functions will not match file or directory names that start with dot . unless matched with a literal dot. DOTMATCH allows the meta characters (such as * ) to match dots like any other character. Dots will not be matched in [] , * , ? , or extended patterns like +(...) .","title":"fnmatch.DOTMATCH, fnmatch.D"},{"location":"fnmatch/#fnmatchextmatch","text":"EXTMATCH enables extended pattern matching. This includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information.","title":"fnmatch.EXTMATCH, fnmatch.E"},{"location":"fnmatch/#fnmatchbrace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns.","title":"fnmatch.BRACE, fnmatch.B"},{"location":"glob/","text":"wcmatch.glob \ue157 from wcmatch import glob Syntax \ue157 The glob library provides methods for traversing the file system and returning files that matched a defined set of glob patterns. The library also provides functions for matching file paths which is similar to fnmatch , but for paths. In short, globmatch matches what glob globs . globmatch 's features are similar to fnmatch 's. Tip When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything except slashes. On Windows it will avoid matching backslashes as well as slashes. ** Matches zero or more directories, but will never match the directories . and .. . ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. [[:alnum:]] POSIX style character classes inside sequences. The C locale is used for byte strings and Unicode properties for Unicode strings. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character, it will be treated as a normal character. ! Inverse pattern (with configuration, can use - instead of ! ). ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . {} Bash style brace expansions. This is applied to patterns before anything else. Slashes are generally treated special in glob related methods. Slashes are not matched in [] , * , ? , or extended patterns like *(...) . Slashes can be matched by ** unless NOGLOBSTAR is set. On Windows, slashes will be normalized in paths and patterns: / will become \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, it will be handled. On Windows, drives are treated special and must come at the beginning of the pattern and cannot be matched with * , [] , ? , or even extended match patterns like +(...) . Windows drives are recognized as either C:\\\\ or \\\\\\\\Server\\\\mount\\\\ (or C:/ and //Server/mount/ ). Meta characters have no effect when inside a UNC path: \\\\\\\\Server?\\\\mount*\\\\ . If case sensitivity is applied on a Windows system, slashes will not be normalized and pattern and paths will be treated as if on Linux/Unix. Also Windows drives are no longer handled special. One exception is when using the functions glob or iglob . Since glob and iglob work on the actual file system of the host, it must normalize slashes and handle drives to work properly on the system. By default, file and directory names starting with . are only matched with literal . . The patterns * , ? , [] , and extended patterns like *(...) will not match a leading . . To alter this behavior, you can use the DOTGLOB flab, but even with DOTGLOB , * and ** will not match a directory . or .. . But a pattern like .* will match . and .. . Relative paths and patterns are supported. >>> from wcmatch import glob >>> glob . glob ( './docs/src/../*' ) ['./docs/src/../src', './docs/src/../theme'] In general, Wildcard Match's behavior is modeled off of Bash's, so unlike the Python's default glob , Wildcard Match's glob will match and return . and .. in certain cases just like Bash does. Python's default: >>> import glob >>> glob . glob ( 'docs/.*' ) [] Wcmatch: >>> from wcmatch import glob >>> glob . glob ( 'docs/.*' ) ['docs/.', 'docs/..'] Bash: $ echo docs/.* docs/. docs/.. POSIX Character Classes \ue157 A number of POSIX style character classes are available in the form [:posix:] . They must be used inside sequences: [[:posix:]] . For byte strings, the C locale is used, and the values will for each character class are found in the table below under ASCII . When used in a Unicode string, Unicode properties will be used. [:posix:] \\p{posix} ASCII Unicode alnum Alnum [a-zA-Z0-9] [\\p{L&}\\p{Nd}] alpha Alpha [a-zA-Z] [\\p{L&}] ascii ASCII [\\x00-\\x7F] [\\x00-\\x7F] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] [\\p{Cc}] digit Digit [0-9] [\\p{Nd}] graph Graph [\\x21-\\x7E] [^\\p{Z}\\p{C}] lower Lower [a-z] [\\p{Ll}] print Print [\\x20-\\x7E] [\\P{C}] punct Punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] [\\p{P}\\p{S}] space Space [ \\t\\r\\n\\v\\f] [\\p{Z}\\t\\r\\n\\v\\f] upper Upper [A-Z] [\\p{Lu}] xdigit XDigit [A-Fa-f0-9] [A-Fa-f0-9] API \ue157 glob.glob \ue157 def glob ( patterns , * , flags = 0 ): glob takes a pattern (or list of patterns) and will crawl the file system returning matching files. If a file/folder matches any positive patterns, it is considered a match. If it matches any inverse pattern (when enabling the NEGATE flag), then it will be not be returned. >>> from wcmatch import glob >>> glob . glob ( r '**/*.md' ) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md'] We can also exclude directories and/or files: >>> from wcmatch import glob >>> glob . glob ([ r '**/*.md' , r '!README.md' , r '!**/_snippets' ], flags = glob . NEGATE ) ['docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md'] When a glob pattern ends with a slash, it will only return directories: >>> from wcmatch import glob >>> glob . glob ( r '**/' ) ['__pycache__/', 'docs/', 'docs/src/', 'docs/src/markdown/', 'docs/src/markdown/_snippets/', 'docs/theme/', 'requirements/', 'stuff/', 'tests/', 'tests/__pycache__/', 'wcmatch/', 'wcmatch/__pycache__/'] glob.iglob \ue157 def iglob ( patterns , * , flags = 0 ): iglob is just like glob except it returns an iterator. >>> from wcmatch import glob >>> list ( glob . iglob ( r '**/*.md' )) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md'] glob.globmatch \ue157 def globmatch ( filename , patterns , \\ * , flags = 0 ): globmatch takes a file name, a pattern (or list of patterns), and flags. It will return a boolean indicating whether the file path was matched by the pattern(s). >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , r '**/*/@(*.txt|*.py)' ) True When applying multiple patterns, a file path matches if it matches any of the patterns: >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , [ r '**/*/*.txt' , r '**/*/*.py' ]) True Inverse patterns are allowed as well. >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , r '!**/*/*.txt' , flags = glob . NEGATE ) False >>> glob . globmatch ( 'some/path/test.py' , r '!**/*/*.txt' , flags = glob . NEGATE ) True When inverse patterns are used in conjunction with other patterns, a path will be considered matched if one of the positive patterns match and none of the inverse patterns match. If only inverse patterns are applied, the path must not match any of the patterns. >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , [ r '**/*/*.txt' , r '!**/*/avoid.txt' ], flags = glob . NEGATE ) True >>> glob . globmatch ( 'some/path/avoid.txt' , [ r '**/*/*.txt' , r '!**/*/avoid.txt' ], flags = glob . NEGATE ) False glob.globfilter \ue157 def globfilter ( filenames , patterns , * , flags = 0 ): globfilter takes a list of file paths, a pattern (or list of patterns), and flags. It returns a list of all files paths that matched the pattern(s). The same logic used for globmatch is used for globfilter , albeit more efficient for processing multiple files. >>> from wcmatch import glob >>> glob . globfilter ([ 'some/path/a.txt' , 'b.txt' , 'another/path/c.py' ], r '**/*.txt' ) ['some/path/a.txt', 'b.txt'] glob.globsplit \ue157 def globsplit ( pattern , * , flags = 0 ): globsplit is used to take a string of multiple patterns that are divided by | and split them into separate patterns. This is provided to help with some interfaces they might need a way to define multiple patterns in one input. It takes into account things like sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can escape the dividers if needed ( \\| ). >>> from wcmatch import glob >>> glob . globsplit ( r '**/*.txt|source/*(some|file).py' ) ('**/*.txt', 'source/*(some|file).py') glob.translate \ue157 def translate ( patterns , * , flags = 0 ): translate takes a glob pattern (or list of patterns) and returns two lists: one for positive patterns and one for inverse patterns. The lists contain the regular expressions used for matching the given patterns. >>> from wcmatch import glob >>> glob . translate ( r '**/*.{py,txt}' ) (['^(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.py[\\\\/]*?)$', '^(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.txt[\\\\/]*?)$'], []) >>> glob . translate ( r '!**/*.{py,txt}' , flags = glob . NEGATE ) ([], ['^(?!(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.py[\\\\/]*?)).*?$', '^(?!(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.txt[\\\\/]*?)).*?$']) glob.escape \ue157 def escape ( pattern , unix = False ): This escapes special glob meta characters so they will be treated as literal characters. It escapes using backslashes. It will escape - , ! , * , ? , ( , [ , | , ^ , { , and \\ . On Windows, it will specifically only escape \\ when not already escaped ( \\\\ ). / and \\\\ (on Windows) are not escaped as they are path separators. >>> from wcmatch import glob >>> glob . escape ( 'some/path?/**file** {} .txt' ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt' >>> glob . globmatch ( 'some/path?/**file** {} .txt' , glob . escape ( 'some/path?/**file** {} .txt' )) True On a Windows system, drives are not escaped since meta characters are not parsed in drives. Drives on Windows are generally treated special. This is because a drive could contain special characters like in \\\\?\\c:\\ . escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system, you can force Unix style escaping via the unix parameter. glob.raw_escape \ue157 def raw_escape ( pattern , unix = False ): This is like escape except it will apply raw character string escapes before doing meta character escapes. This is meant for use with the RAWCHARS flag. >>> from wcmatch import glob >>> glob . raw_escape ( 'some/path?/ \\x2a\\x2a file \\x2a\\x2a {} .txt' ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt' >>> glob . globmatch ( 'some/path?/**file** {} .txt' , glob . escape ( 'some/path?/ \\x2a\\x2a file \\x2a\\x2a {} .txt' ), flags = glob . RAWCHARS ) True raw_escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system, you can force Unix style escaping via the unix parameter. Flags \ue157 glob.FORCECASE, glob.F \ue157 FORCECASE forces case sensitivity. On Windows, this will force paths to be treated like Linux/Unix paths, and slashes will not be normalized. Path normalization only relates to globmatch and not for glob and iglob . Paths must be normalized for glob and iglob in order to scan the file system. FORCECASE has higher priority than IGNORECASE . glob.IGNORECASE, glob.I \ue157 IGNORECASE forces case insensitivity. FORCECASE has higher priority than IGNORECASE . glob.RAWCHARS, glob.R \ue157 RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' . glob.NEGATE, glob.N \ue157 NEGATE causes patterns that start with ! to be treated as inverse matches. A pattern of !*.py would match any file but Python files. If used with the extended glob feature, patterns like !(inverse|pattern) will be mistakenly parsed as an inverse pattern instead of as an inverse extended glob group. See MINUSNEGATE for an alternative syntax that plays nice with extended glob. glob.MINUSNEGATE, glob.M \ue157 When MINUSNEGATE is used with NEGATE , negate patterns are recognized by a pattern starting with - instead of ! . This plays nice with the extended glob feature which already uses ! in patterns such as !(...) . glob.GLOBSTAR, glob.G \ue157 GLOBSTAR enables the feature where ** matches zero or more directories. glob.DOTGLOB, glob.D \ue157 By default, glob and globmatch will not match file or directory names that start with dot . unless matched with a literal dot. DOTGLOB allows the meta characters (such as * ) to glob dots like any other character. Dots will not be matched in [] , * , ? , or extended patterns like +(...) . Alternatively DOTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since DOTGLOB is often the name used in Bash. glob.EXTGLOB, glob.E \ue157 EXTGLOB enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information. Alternatively EXTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since EXTGLOB is often the name used in Bash. glob.BRACE, glob.B \ue157 BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTGLOB which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns.","title":"Glob"},{"location":"glob/#wcmatchglob","text":"from wcmatch import glob","title":"wcmatch.glob"},{"location":"glob/#syntax","text":"The glob library provides methods for traversing the file system and returning files that matched a defined set of glob patterns. The library also provides functions for matching file paths which is similar to fnmatch , but for paths. In short, globmatch matches what glob globs . globmatch 's features are similar to fnmatch 's. Tip When using backslashes, it is helpful to use raw strings. In a raw string, a single backslash is used to escape a character r '\\?' . If you want to represent a literal backslash, you must use two: r 'some \\\\ path' . Pattern Meaning * Matches everything except slashes. On Windows it will avoid matching backslashes as well as slashes. ** Matches zero or more directories, but will never match the directories . and .. . ? Matches any single character. [seq] Matches any character in seq. [!seq] Matches any character not in seq. [[:alnum:]] POSIX style character classes inside sequences. The C locale is used for byte strings and Unicode properties for Unicode strings. See POSIX Character Classes for more info. \\ Escapes characters. If applied to a meta character, it will be treated as a normal character. ! Inverse pattern (with configuration, can use - instead of ! ). ?(pattern_list) The pattern matches if zero or one occurrences of any of the patterns in the pattern_list match the input string. *(pattern_list) The pattern matches if zero or more occurrences of any of the patterns in the pattern_list match the input string. +(pattern_list) The pattern matches if one or more occurrences of any of the patterns in the pattern_list match the input string. @(pattern_list) The pattern matches if exactly one occurrence of any of the patterns in the pattern_list match the input string. !(pattern_list) The pattern matches if the input string cannot be matched with any of the patterns in the pattern_list . {} Bash style brace expansions. This is applied to patterns before anything else. Slashes are generally treated special in glob related methods. Slashes are not matched in [] , * , ? , or extended patterns like *(...) . Slashes can be matched by ** unless NOGLOBSTAR is set. On Windows, slashes will be normalized in paths and patterns: / will become \\\\ . There is no need to explicitly use \\\\ in patterns on Windows, but if you do, it will be handled. On Windows, drives are treated special and must come at the beginning of the pattern and cannot be matched with * , [] , ? , or even extended match patterns like +(...) . Windows drives are recognized as either C:\\\\ or \\\\\\\\Server\\\\mount\\\\ (or C:/ and //Server/mount/ ). Meta characters have no effect when inside a UNC path: \\\\\\\\Server?\\\\mount*\\\\ . If case sensitivity is applied on a Windows system, slashes will not be normalized and pattern and paths will be treated as if on Linux/Unix. Also Windows drives are no longer handled special. One exception is when using the functions glob or iglob . Since glob and iglob work on the actual file system of the host, it must normalize slashes and handle drives to work properly on the system. By default, file and directory names starting with . are only matched with literal . . The patterns * , ? , [] , and extended patterns like *(...) will not match a leading . . To alter this behavior, you can use the DOTGLOB flab, but even with DOTGLOB , * and ** will not match a directory . or .. . But a pattern like .* will match . and .. . Relative paths and patterns are supported. >>> from wcmatch import glob >>> glob . glob ( './docs/src/../*' ) ['./docs/src/../src', './docs/src/../theme'] In general, Wildcard Match's behavior is modeled off of Bash's, so unlike the Python's default glob , Wildcard Match's glob will match and return . and .. in certain cases just like Bash does. Python's default: >>> import glob >>> glob . glob ( 'docs/.*' ) [] Wcmatch: >>> from wcmatch import glob >>> glob . glob ( 'docs/.*' ) ['docs/.', 'docs/..'] Bash: $ echo docs/.* docs/. docs/..","title":"Syntax"},{"location":"glob/#posix-character-classes","text":"A number of POSIX style character classes are available in the form [:posix:] . They must be used inside sequences: [[:posix:]] . For byte strings, the C locale is used, and the values will for each character class are found in the table below under ASCII . When used in a Unicode string, Unicode properties will be used. [:posix:] \\p{posix} ASCII Unicode alnum Alnum [a-zA-Z0-9] [\\p{L&}\\p{Nd}] alpha Alpha [a-zA-Z] [\\p{L&}] ascii ASCII [\\x00-\\x7F] [\\x00-\\x7F] blank Blank [ \\t] [\\p{Zs}\\t] cntrl Cntrl [\\x00-\\x1F\\x7F] [\\p{Cc}] digit Digit [0-9] [\\p{Nd}] graph Graph [\\x21-\\x7E] [^\\p{Z}\\p{C}] lower Lower [a-z] [\\p{Ll}] print Print [\\x20-\\x7E] [\\P{C}] punct Punct [!\\\"\\#$%&'()*+,\\-./:;<=>?@\\[\\\\\\]^_`{}~] [\\p{P}\\p{S}] space Space [ \\t\\r\\n\\v\\f] [\\p{Z}\\t\\r\\n\\v\\f] upper Upper [A-Z] [\\p{Lu}] xdigit XDigit [A-Fa-f0-9] [A-Fa-f0-9]","title":"POSIX Character Classes"},{"location":"glob/#api","text":"","title":"API"},{"location":"glob/#globglob","text":"def glob ( patterns , * , flags = 0 ): glob takes a pattern (or list of patterns) and will crawl the file system returning matching files. If a file/folder matches any positive patterns, it is considered a match. If it matches any inverse pattern (when enabling the NEGATE flag), then it will be not be returned. >>> from wcmatch import glob >>> glob . glob ( r '**/*.md' ) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md'] We can also exclude directories and/or files: >>> from wcmatch import glob >>> glob . glob ([ r '**/*.md' , r '!README.md' , r '!**/_snippets' ], flags = glob . NEGATE ) ['docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md'] When a glob pattern ends with a slash, it will only return directories: >>> from wcmatch import glob >>> glob . glob ( r '**/' ) ['__pycache__/', 'docs/', 'docs/src/', 'docs/src/markdown/', 'docs/src/markdown/_snippets/', 'docs/theme/', 'requirements/', 'stuff/', 'tests/', 'tests/__pycache__/', 'wcmatch/', 'wcmatch/__pycache__/']","title":"glob.glob"},{"location":"glob/#globiglob","text":"def iglob ( patterns , * , flags = 0 ): iglob is just like glob except it returns an iterator. >>> from wcmatch import glob >>> list ( glob . iglob ( r '**/*.md' )) ['docs/src/markdown/_snippets/abbr.md', 'docs/src/markdown/_snippets/links.md', 'docs/src/markdown/_snippets/refs.md', 'docs/src/markdown/changelog.md', 'docs/src/markdown/fnmatch.md', 'docs/src/markdown/glob.md', 'docs/src/markdown/index.md', 'docs/src/markdown/installation.md', 'docs/src/markdown/license.md', 'README.md']","title":"glob.iglob"},{"location":"glob/#globglobmatch","text":"def globmatch ( filename , patterns , \\ * , flags = 0 ): globmatch takes a file name, a pattern (or list of patterns), and flags. It will return a boolean indicating whether the file path was matched by the pattern(s). >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , r '**/*/@(*.txt|*.py)' ) True When applying multiple patterns, a file path matches if it matches any of the patterns: >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , [ r '**/*/*.txt' , r '**/*/*.py' ]) True Inverse patterns are allowed as well. >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , r '!**/*/*.txt' , flags = glob . NEGATE ) False >>> glob . globmatch ( 'some/path/test.py' , r '!**/*/*.txt' , flags = glob . NEGATE ) True When inverse patterns are used in conjunction with other patterns, a path will be considered matched if one of the positive patterns match and none of the inverse patterns match. If only inverse patterns are applied, the path must not match any of the patterns. >>> from wcmatch import glob >>> glob . globmatch ( 'some/path/test.txt' , [ r '**/*/*.txt' , r '!**/*/avoid.txt' ], flags = glob . NEGATE ) True >>> glob . globmatch ( 'some/path/avoid.txt' , [ r '**/*/*.txt' , r '!**/*/avoid.txt' ], flags = glob . NEGATE ) False","title":"glob.globmatch"},{"location":"glob/#globglobfilter","text":"def globfilter ( filenames , patterns , * , flags = 0 ): globfilter takes a list of file paths, a pattern (or list of patterns), and flags. It returns a list of all files paths that matched the pattern(s). The same logic used for globmatch is used for globfilter , albeit more efficient for processing multiple files. >>> from wcmatch import glob >>> glob . globfilter ([ 'some/path/a.txt' , 'b.txt' , 'another/path/c.py' ], r '**/*.txt' ) ['some/path/a.txt', 'b.txt']","title":"glob.globfilter"},{"location":"glob/#globglobsplit","text":"def globsplit ( pattern , * , flags = 0 ): globsplit is used to take a string of multiple patterns that are divided by | and split them into separate patterns. This is provided to help with some interfaces they might need a way to define multiple patterns in one input. It takes into account things like sequences ( [] ) and extended patterns ( *(...) ) and will not parse | within them. You can escape the dividers if needed ( \\| ). >>> from wcmatch import glob >>> glob . globsplit ( r '**/*.txt|source/*(some|file).py' ) ('**/*.txt', 'source/*(some|file).py')","title":"glob.globsplit"},{"location":"glob/#globtranslate","text":"def translate ( patterns , * , flags = 0 ): translate takes a glob pattern (or list of patterns) and returns two lists: one for positive patterns and one for inverse patterns. The lists contain the regular expressions used for matching the given patterns. >>> from wcmatch import glob >>> glob . translate ( r '**/*.{py,txt}' ) (['^(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.py[\\\\/]*?)$', '^(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.txt[\\\\/]*?)$'], []) >>> glob . translate ( r '!**/*.{py,txt}' , flags = glob . NEGATE ) ([], ['^(?!(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.py[\\\\/]*?)).*?$', '^(?!(?s:(?:(?!(?:\\\\/|^)\\\\.).)*?(?:^|$|\\\\/)+(?=.)(?!(?:\\\\.{1,2})(?:$|\\\\/))(?:(?!\\\\.)[^\\\\/]*?)?\\\\.txt[\\\\/]*?)).*?$'])","title":"glob.translate"},{"location":"glob/#globescape","text":"def escape ( pattern , unix = False ): This escapes special glob meta characters so they will be treated as literal characters. It escapes using backslashes. It will escape - , ! , * , ? , ( , [ , | , ^ , { , and \\ . On Windows, it will specifically only escape \\ when not already escaped ( \\\\ ). / and \\\\ (on Windows) are not escaped as they are path separators. >>> from wcmatch import glob >>> glob . escape ( 'some/path?/**file** {} .txt' ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt' >>> glob . globmatch ( 'some/path?/**file** {} .txt' , glob . escape ( 'some/path?/**file** {} .txt' )) True On a Windows system, drives are not escaped since meta characters are not parsed in drives. Drives on Windows are generally treated special. This is because a drive could contain special characters like in \\\\?\\c:\\ . escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system, you can force Unix style escaping via the unix parameter.","title":"glob.escape"},{"location":"glob/#globraw_escape","text":"def raw_escape ( pattern , unix = False ): This is like escape except it will apply raw character string escapes before doing meta character escapes. This is meant for use with the RAWCHARS flag. >>> from wcmatch import glob >>> glob . raw_escape ( 'some/path?/ \\x2a\\x2a file \\x2a\\x2a {} .txt' ) 'some/path\\\\?/\\\\*\\\\*file\\\\*\\\\*\\\\{}.txt' >>> glob . globmatch ( 'some/path?/**file** {} .txt' , glob . escape ( 'some/path?/ \\x2a\\x2a file \\x2a\\x2a {} .txt' ), flags = glob . RAWCHARS ) True raw_escape will detect the system it is running on and pick Windows escape logic or Linux/Unix logic. Since globmatch allows you to match Unix style paths on a Windows system, you can force Unix style escaping via the unix parameter.","title":"glob.raw_escape"},{"location":"glob/#flags","text":"","title":"Flags"},{"location":"glob/#globforcecase","text":"FORCECASE forces case sensitivity. On Windows, this will force paths to be treated like Linux/Unix paths, and slashes will not be normalized. Path normalization only relates to globmatch and not for glob and iglob . Paths must be normalized for glob and iglob in order to scan the file system. FORCECASE has higher priority than IGNORECASE .","title":"glob.FORCECASE, glob.F"},{"location":"glob/#globignorecase","text":"IGNORECASE forces case insensitivity. FORCECASE has higher priority than IGNORECASE .","title":"glob.IGNORECASE, glob.I"},{"location":"glob/#globrawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode including r '\\N{CHAR NAME}' .","title":"glob.RAWCHARS, glob.R"},{"location":"glob/#globnegate","text":"NEGATE causes patterns that start with ! to be treated as inverse matches. A pattern of !*.py would match any file but Python files. If used with the extended glob feature, patterns like !(inverse|pattern) will be mistakenly parsed as an inverse pattern instead of as an inverse extended glob group. See MINUSNEGATE for an alternative syntax that plays nice with extended glob.","title":"glob.NEGATE, glob.N"},{"location":"glob/#globminusnegate","text":"When MINUSNEGATE is used with NEGATE , negate patterns are recognized by a pattern starting with - instead of ! . This plays nice with the extended glob feature which already uses ! in patterns such as !(...) .","title":"glob.MINUSNEGATE, glob.M"},{"location":"glob/#globglobstar","text":"GLOBSTAR enables the feature where ** matches zero or more directories.","title":"glob.GLOBSTAR, glob.G"},{"location":"glob/#globdotglob","text":"By default, glob and globmatch will not match file or directory names that start with dot . unless matched with a literal dot. DOTGLOB allows the meta characters (such as * ) to glob dots like any other character. Dots will not be matched in [] , * , ? , or extended patterns like +(...) . Alternatively DOTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since DOTGLOB is often the name used in Bash.","title":"glob.DOTGLOB, glob.D"},{"location":"glob/#globextglob","text":"EXTGLOB enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. See the syntax overview for more information. Alternatively EXTMATCH will also be accepted for consistency with the other provided libraries. Both flags are exactly the same and are provided as a convenience in case the user finds one more intuitive than the other since EXTGLOB is often the name used in Bash.","title":"glob.EXTGLOB, glob.E"},{"location":"glob/#globbrace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTGLOB which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns.","title":"glob.BRACE, glob.B"},{"location":"license/","text":"License \ue157 Wildcard Match \ue157 The MIT License (MIT) Copyright \u00a9 2018 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"","title":"License"},{"location":"license/#wildcard-match","text":"The MIT License (MIT) Copyright \u00a9 2018 Isaac Muse Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Wildcard Match"},{"location":"wcmatch/","text":"wcmatch.wcmatch \ue157 from wcmatch import wcmatch Overview \ue157 wcmatch.WcMatch was originally written to provide a simple user interface for searching specific files in Rummage . A class was needed to facilitate a user interface where a user could select a base path, define one or more file patterns they wanted to search for, and provide folders to exclude if needed. It needed to be aware of hidden files on different systems, not just ignoring files that start with . . It also needed to be extendable so we could further filter returned files by size, creation date, or whatever else was decided. While glob is a fantastic file and folder search tool, it just didn't make sense for such a user interface. wcmatch.WcMatch \ue157 WcMatch is an extendable file search class. It allows you to specify a base path, file patterns, and optional folder exclude patterns. You can specify whether you want to see hidden files and whether the search should be recursive. You can also derive from the class and tap into specific hooks to change what is returned or done when a file is matched, skipped, or when there is an error. There are also hooks where you can inject additional, custom filtering. Parameter Default Description directory The base directory to search. file_pattern '' One or more patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). The default is an empty string, but if an empty string is used, all files will be matched. exclude_pattern '' Zero or more folder exclude patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). recursive False Whether search should be recursive. show_hidden False Whether hidden files should be shown. flags 0 Flags to alter behavior of folder and file matching. See Flags for more info. Note Dots are not treated special. When show_hidden is disabled, dot files won't show up anyways, so it is expected that if show_hidden is enabled, that * , ? , [] , etc. should match . . Examples \ue157 Searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md'] Recursively searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , recursive = True ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/installation.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md', './docs/src/markdown/_snippets/abbr.md', './docs/src/markdown/_snippets/links.md', './docs/src/markdown/_snippets/refs.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Excluding directories: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , 'docs' , recursive = True ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Using file negation patterns: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt|!README*' , 'docs' , recursive = True ) . match () ['./LICENSE.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] You can also use negation patterns in directory exclude. Here we avoid all folders with * , but add an exception for requirements . It should be noted that you cannot add an exception for the child of an excluded folder. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '*|!requirements' , recursive = True ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Negative patterns can be given by themselves. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '!requirements' , recursive = True ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Enabling hidden files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.yml' ) . match () ['./appveyor.yml', './mkdocs.yml'] >>> wcmatch . WcMatch ( '.' , '*.yml' , show_hidden = True ) . match () ['./.codecov.yml', './.travis.yml', './appveyor.yml', './mkdocs.yml'] Methods \ue157 WcMatch.match \ue157 Perform match returning files that match the patterns. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md'] WcMatch.imatch \ue157 Perform match returning an iterator of files that match the patterns. >>> from wcmatch import wcmatch >>> list ( wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . imatch ()) ['./LICENSE.md', './README.md'] WcMatch.kill \ue157 If searching with imatch , this provides a way to kill the internal searching. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md WcMatch.reset \ue157 Resets the abort state after running kill . >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md >>> wcm . reset () >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md'] WcMatch.get_skipped \ue157 Returns the number of skipped files. Files in skipped folders are not included in the count. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md'] >>> wcm . get_skipped () 10 Hooks \ue157 WcMatch.on_init \ue157 def on_init ( self , * args , ** kwargs ): \"\"\"Handle custom init.\"\"\" Any arguments or keyword arguments not processed by the main initializer are sent to on_init . This allows you to specify additional arguments when deriving from WcMatch . WcMatch.on_validate_directory \ue157 def on_validate_directory ( self , base , name ): \"\"\"Validate folder override.\"\"\" return True When validating a directory, if the directory passes validation, it will be sent to on_validate_directory which can be overridden to provide additional validation if required. WcMatch.on_validate_file \ue157 def on_validate_file ( self , base , name ): \"\"\"Validate file override.\"\"\" return True When validating a file, if the file passes validation, it will be sent to on_validate_file which can be overridden to provide additional validation if required. WcMatch.on_skip \ue157 def on_skip ( self , base , name ): \"\"\"On skip.\"\"\" return None When a file that must be skipped is encountered (a file that doesn't pass validation), it is sent to on_skip . Here you could abort the search, store away information, or even create a special skip record to return. It is advised to create a special type for skip returns so that you can identify them when they are returned via match or imatch . WcMatch.on_error \ue157 def on_error ( self , base , name ): \"\"\"On error.\"\"\" return None When accessing or processing a file throws an error, it is sent to on_error . Here you could abort the search, store away information, or even create a special error record to return. It is advised to create a special type for error returns so that you can identify them when they are returned via match or imatch . WcMatch.on_match \ue157 def on_match ( self , base , name ): \"\"\"On match.\"\"\" return os . path . join ( base , name ) On match returns the path of the matched file. You can override on_match and change what is returned. You could return just the base, you could parse the file and return the content, or return a special match record with additional file meta data. on_match must return something, and all results will be returned via match or imatch . Flags \ue157 wcmatch.FORCECASE, wcmatch.F \ue157 FORCECASE forces cased searches. FORCECASE has higher priority than IGNORECASE . This does not affect path normalization. All paths are normalized for the host as it is required to properly access the file system. wcmatch.IGNORECASE, wcmatch.I \ue157 IGNORECASE forces case insensitive searches. FORCECASE has higher priority than IGNORECASE . wcmatch.RAWCHARS, wcmatch.R \ue157 RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode (including r '\\N{CHAR NAME}' ). wcmatch.EXTMATCH, wcmatch.E \ue157 EXTMATCH enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc. wcmatch.BRACE, wcmatch.B \ue157 BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns. wcmatch.MINUSNEGATE, wcmatch.M \ue157 MINUSNEGATE requires negation patterns to use - instead of ! . wcmatch.DIRPATHNAME, wcmatch.DP \ue157 DIRPATHNAME will enable path name searching for excluded folder patterns, but it will not apply to file patterns. This is mainly provided for cases where you may have multiple folders with the same name, but you want to target a specific folder to exclude. The path name compared will be the entire path relative to the base path. So if the provided base folder was . , and the folder under evaluation is ./some/folder , some/folder will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , 'docs/src/markdown' , recursive = True , flags = wcmatch . DIRPATHNAME ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] wcmatch.FILEPATHNAME, wcmatch.FP \ue157 FILEPATHNAME will enable path name searching for the file patterns, but it will not apply to directory exclude patterns. The path name compared will be the entire path relative to the base path. So if the provided base folder was . , and the file under evaluation is ./some/file.txt , some/file.txt will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '**/*.md|!**/_snippets/*' , recursive = True , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md'] wcmatch.PATHNAME, wcmatch.P \ue157 PATHNAME enables both DIRPATHNAME and FILEPATHNAME . It is provided for convenience. wcmatch.GLOBSTAR, wcmatch.G \ue157 When the PATHNAME flag is provided, you can also enable GLOBSTAR to enable the recursive directory pattern matches with ** . >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '**/markdown' , recursive = True , flags = wcmatch . DIRPATHNAME | wcmatch . GLOBSTAR ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']","title":"Wcmatch"},{"location":"wcmatch/#wcmatchwcmatch","text":"from wcmatch import wcmatch","title":"wcmatch.wcmatch"},{"location":"wcmatch/#overview","text":"wcmatch.WcMatch was originally written to provide a simple user interface for searching specific files in Rummage . A class was needed to facilitate a user interface where a user could select a base path, define one or more file patterns they wanted to search for, and provide folders to exclude if needed. It needed to be aware of hidden files on different systems, not just ignoring files that start with . . It also needed to be extendable so we could further filter returned files by size, creation date, or whatever else was decided. While glob is a fantastic file and folder search tool, it just didn't make sense for such a user interface.","title":"Overview"},{"location":"wcmatch/#wcmatchwcmatch_1","text":"WcMatch is an extendable file search class. It allows you to specify a base path, file patterns, and optional folder exclude patterns. You can specify whether you want to see hidden files and whether the search should be recursive. You can also derive from the class and tap into specific hooks to change what is returned or done when a file is matched, skipped, or when there is an error. There are also hooks where you can inject additional, custom filtering. Parameter Default Description directory The base directory to search. file_pattern '' One or more patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). The default is an empty string, but if an empty string is used, all files will be matched. exclude_pattern '' Zero or more folder exclude patterns separated by | . You can define exceptions by starting a pattern with ! (or - if MINUSNEGATE is set). recursive False Whether search should be recursive. show_hidden False Whether hidden files should be shown. flags 0 Flags to alter behavior of folder and file matching. See Flags for more info. Note Dots are not treated special. When show_hidden is disabled, dot files won't show up anyways, so it is expected that if show_hidden is enabled, that * , ? , [] , etc. should match . .","title":"wcmatch.WcMatch"},{"location":"wcmatch/#examples","text":"Searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md'] Recursively searching for files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , recursive = True ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/installation.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md', './docs/src/markdown/_snippets/abbr.md', './docs/src/markdown/_snippets/links.md', './docs/src/markdown/_snippets/refs.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Excluding directories: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , 'docs' , recursive = True ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Using file negation patterns: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt|!README*' , 'docs' , recursive = True ) . match () ['./LICENSE.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] You can also use negation patterns in directory exclude. Here we avoid all folders with * , but add an exception for requirements . It should be noted that you cannot add an exception for the child of an excluded folder. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '*|!requirements' , recursive = True ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Negative patterns can be given by themselves. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '!requirements' , recursive = True ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt'] Enabling hidden files: >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.yml' ) . match () ['./appveyor.yml', './mkdocs.yml'] >>> wcmatch . WcMatch ( '.' , '*.yml' , show_hidden = True ) . match () ['./.codecov.yml', './.travis.yml', './appveyor.yml', './mkdocs.yml']","title":"Examples"},{"location":"wcmatch/#methods","text":"","title":"Methods"},{"location":"wcmatch/#wcmatchmatch","text":"Perform match returning files that match the patterns. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . match () ['./LICENSE.md', './README.md']","title":"WcMatch.match"},{"location":"wcmatch/#wcmatchimatch","text":"Perform match returning an iterator of files that match the patterns. >>> from wcmatch import wcmatch >>> list ( wcmatch . WcMatch ( '.' , '*.md|*.txt' ) . imatch ()) ['./LICENSE.md', './README.md']","title":"WcMatch.imatch"},{"location":"wcmatch/#wcmatchkill","text":"If searching with imatch , this provides a way to kill the internal searching. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md","title":"WcMatch.kill"},{"location":"wcmatch/#wcmatchreset","text":"Resets the abort state after running kill . >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> for f in wcm . imatch (): ... print ( f ) ... wcm . kill () ... ./LICENSE.md >>> wcm . reset () >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md']","title":"WcMatch.reset"},{"location":"wcmatch/#wcmatchget_skipped","text":"Returns the number of skipped files. Files in skipped folders are not included in the count. >>> from wcmatch import wcmatch >>> wcm = wcmatch . WcMatch ( '.' , '*.md|*.txt' ) >>> list ( wcm . imatch ()) ['./LICENSE.md', './README.md'] >>> wcm . get_skipped () 10","title":"WcMatch.get_skipped"},{"location":"wcmatch/#hooks","text":"","title":"Hooks"},{"location":"wcmatch/#wcmatchon_init","text":"def on_init ( self , * args , ** kwargs ): \"\"\"Handle custom init.\"\"\" Any arguments or keyword arguments not processed by the main initializer are sent to on_init . This allows you to specify additional arguments when deriving from WcMatch .","title":"WcMatch.on_init"},{"location":"wcmatch/#wcmatchon_validate_directory","text":"def on_validate_directory ( self , base , name ): \"\"\"Validate folder override.\"\"\" return True When validating a directory, if the directory passes validation, it will be sent to on_validate_directory which can be overridden to provide additional validation if required.","title":"WcMatch.on_validate_directory"},{"location":"wcmatch/#wcmatchon_validate_file","text":"def on_validate_file ( self , base , name ): \"\"\"Validate file override.\"\"\" return True When validating a file, if the file passes validation, it will be sent to on_validate_file which can be overridden to provide additional validation if required.","title":"WcMatch.on_validate_file"},{"location":"wcmatch/#wcmatchon_skip","text":"def on_skip ( self , base , name ): \"\"\"On skip.\"\"\" return None When a file that must be skipped is encountered (a file that doesn't pass validation), it is sent to on_skip . Here you could abort the search, store away information, or even create a special skip record to return. It is advised to create a special type for skip returns so that you can identify them when they are returned via match or imatch .","title":"WcMatch.on_skip"},{"location":"wcmatch/#wcmatchon_error","text":"def on_error ( self , base , name ): \"\"\"On error.\"\"\" return None When accessing or processing a file throws an error, it is sent to on_error . Here you could abort the search, store away information, or even create a special error record to return. It is advised to create a special type for error returns so that you can identify them when they are returned via match or imatch .","title":"WcMatch.on_error"},{"location":"wcmatch/#wcmatchon_match","text":"def on_match ( self , base , name ): \"\"\"On match.\"\"\" return os . path . join ( base , name ) On match returns the path of the matched file. You can override on_match and change what is returned. You could return just the base, you could parse the file and return the content, or return a special match record with additional file meta data. on_match must return something, and all results will be returned via match or imatch .","title":"WcMatch.on_match"},{"location":"wcmatch/#flags","text":"","title":"Flags"},{"location":"wcmatch/#wcmatchforcecase","text":"FORCECASE forces cased searches. FORCECASE has higher priority than IGNORECASE . This does not affect path normalization. All paths are normalized for the host as it is required to properly access the file system.","title":"wcmatch.FORCECASE, wcmatch.F"},{"location":"wcmatch/#wcmatchignorecase","text":"IGNORECASE forces case insensitive searches. FORCECASE has higher priority than IGNORECASE .","title":"wcmatch.IGNORECASE, wcmatch.I"},{"location":"wcmatch/#wcmatchrawchars","text":"RAWCHARS causes string character syntax to be parsed in raw strings: r '\\u0040' \u2192 r '@' . This will handle standard string escapes and Unicode (including r '\\N{CHAR NAME}' ).","title":"wcmatch.RAWCHARS, wcmatch.R"},{"location":"wcmatch/#wcmatchextmatch","text":"EXTMATCH enables extended pattern matching which includes special pattern lists such as +(...) , *(...) , ?(...) , etc.","title":"wcmatch.EXTMATCH, wcmatch.E"},{"location":"wcmatch/#wcmatchbrace","text":"BRACE enables Bash style brace expansion: a{b,{c,d}} \u2192 ab ac ad . Brace expansion is applied before anything else. When applied, a pattern will be expanded into multiple patterns. Each pattern will then be parsed separately. For simple patterns, it may make more sense to use EXTMATCH which will only generate a single pattern: @(ab|ac|ad) . Be careful with patterns such as {1..100} which would generate one hundred patterns that will all get individually parsed. Sometimes you really need such a pattern, but be mindful that it will be slower as you generate larger sets of patterns.","title":"wcmatch.BRACE, wcmatch.B"},{"location":"wcmatch/#wcmatchminusnegate","text":"MINUSNEGATE requires negation patterns to use - instead of ! .","title":"wcmatch.MINUSNEGATE, wcmatch.M"},{"location":"wcmatch/#wcmatchdirpathname","text":"DIRPATHNAME will enable path name searching for excluded folder patterns, but it will not apply to file patterns. This is mainly provided for cases where you may have multiple folders with the same name, but you want to target a specific folder to exclude. The path name compared will be the entire path relative to the base path. So if the provided base folder was . , and the folder under evaluation is ./some/folder , some/folder will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , 'docs/src/markdown' , recursive = True , flags = wcmatch . DIRPATHNAME ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']","title":"wcmatch.DIRPATHNAME, wcmatch.DP"},{"location":"wcmatch/#wcmatchfilepathname","text":"FILEPATHNAME will enable path name searching for the file patterns, but it will not apply to directory exclude patterns. The path name compared will be the entire path relative to the base path. So if the provided base folder was . , and the file under evaluation is ./some/file.txt , some/file.txt will be matched against the pattern. >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '**/*.md|!**/_snippets/*' , recursive = True , flags = wcmatch . FILEPATHNAME | wcmatch . GLOBSTAR ) . match () ['./LICENSE.md', './README.md', './docs/src/markdown/changelog.md', './docs/src/markdown/fnmatch.md', './docs/src/markdown/glob.md', './docs/src/markdown/index.md', './docs/src/markdown/license.md', './docs/src/markdown/wcmatch.md']","title":"wcmatch.FILEPATHNAME, wcmatch.FP"},{"location":"wcmatch/#wcmatchpathname","text":"PATHNAME enables both DIRPATHNAME and FILEPATHNAME . It is provided for convenience.","title":"wcmatch.PATHNAME, wcmatch.P"},{"location":"wcmatch/#wcmatchglobstar","text":"When the PATHNAME flag is provided, you can also enable GLOBSTAR to enable the recursive directory pattern matches with ** . >>> from wcmatch import wcmatch >>> wcmatch . WcMatch ( '.' , '*.md|*.txt' , '**/markdown' , recursive = True , flags = wcmatch . DIRPATHNAME | wcmatch . GLOBSTAR ) . match () ['./LICENSE.md', './README.md', './requirements/docs.txt', './requirements/lint.txt', './requirements/setup.txt', './requirements/test.txt']","title":"wcmatch.GLOBSTAR, wcmatch.G"}]}